import java.util.HashSet;
aspect ErrorCollection {
    coll HashSet<String> Program.semanticErrors() [new HashSet<String>()] with add;
    syn boolean Program.hasSemanticErrors() = !semanticErrors().isEmpty();
    syn String Program.errorReport() {
        StringBuilder sb = new StringBuilder();
        for(String err : semanticErrors()) sb.append(err).append("\n");
        return sb.toString();
    }
}

aspect EmptyRelationUse {
    syn boolean FormalPredicate.hasRuleUse() {
        for(PredicateSymbol pred : predicates()) {
    		if(pred.isUse()) return true;
    	}
    	return false;
    }
    
    syn boolean FormalPredicate.hasRuleDef() {
        for(PredicateSymbol pred : predicates()) {
    		if(pred.isDef()) return true;
    	}
    	return false;
    }
    
   syn boolean FormalPredicate.hasRuleOccurrence() {
    	return hasRuleDef() || hasRuleUse();
    }
    
    syn boolean FormalPredicate.mayHaveFacts() {
    	for(PredicateSymbol pred : predicates()) {
    		if(pred.isFact() || pred.isDef() || pred.isEDBFact()) return true;
    	}
    	return false;
    }
    
    Program contributes nta getFormalPredicateList() to Program.semanticErrors();
    FormalPredicate contributes ("The use of " + predicateName() + " can give no facts")
    	when !mayHaveFacts() && hasRuleUse()
    	to Program.semanticErrors();
}

aspect UnusedRelation {
    Program contributes nta getFormalPredicateList() to Program.semanticErrors();
    FormalPredicate contributes ("The predicate " + predicateName() + " has no rule occurrence.")
    	when !hasRuleOccurrence()
    	to Program.semanticErrors();
}