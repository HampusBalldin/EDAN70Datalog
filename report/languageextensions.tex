A number of language features have been added in addition to the core Datalog features. Those extensions are listed and briefly described in the following subsections.
\vspace*{-5 pt}
\subsection{Negation}
A common datalog extension is to allow negation ($\neg$) of atoms. However, unrestricted negation introduces semantic issues as the following example illustrates:

\NL
{\centering
	$A(x) \coloneqtwo \neg B(x).\qquad\qquad[r_1]$ \NL
	$B(x) \coloneqtwo \neg A(x).\qquad\qquad[r_2]$\par
}

\NL
There are two issues with the above example. First, no unique minimal model exists: if $r_1$ is evaluated first then $A = \Omega, B = \emptyset$, and if $r_2$ is evaluated first then $A = \emptyset, B = \Omega$. Second, even if a unique minimal model exists, guaranteed termination is lost since negation removes monotonicity (adding tuples to one relation may remove tuples from another). The first issue is addressed by ensuring that all variable terms used in a negated atom are also used in a non-negated (\textit{positive}) atom. Second, we require that each stratum retains the monotonic property, in particular this means that mutual recursive dependencies must be positive.

With the above restrictions, negation becomes a filtering rule; an occurrence of a negated atom within a rule has already been fully evaluated when that rule is considered in a stratum. Thus restricted negation can be implemented as a set-difference over the artificial body relation (introduced in the previous section).

\subsection{Built-in Predicates and Expressions}
Most (if not all) Datalog systems include various built-in predicates for discarding certain results based on some criteria. The current implementation includes the usual binary predicates $=, \neq, \leq, \ldots$ They can be used with expressions over the usual binary operators $+,-,*,/$. To continue with the order example, a relation that picks ordered tuples with elements at least two units apart is shown below:

\NL
{\centering
	$TwoGapOrder(x, y) \coloneqtwo Order(x, y), x \leq y - 2.$ \NL
}

\vspace*{-\baselineskip}
\subsection{Object Creation}
A special bind predicate was introduced to allow for the creation of new objects. Combined with \textit{aggregates}, such as counting the number of elements in a relation, this is a useful way to let datalog reason about properties of the currently evaluating program. However, the new expressive power may lead to non-terminating programs as the following example for generating the natural numbers illustrates. No checks have been added to detect this divergence.

\begin{minted}{yaml}
Nat(0).
Nat(y) :- Nat(x), BIND(y, x + 1).
\end{minted}
\noindent

\subsection{Type System}
The language includes a simple type system. The basic types are:
\begin{align*}
	String : * \quad Integer : *, \quad PredRef : * 
\end{align*}
\noindent
The types are themselves terms and the star means the type of a type. The $PredRef$ type is used to reference predicates and forms the basis for meta-predicates. Last, the type system has a List \textit{type-constructor}, i.e. it is a function from a term of type $*$ that gives another term of type $*$:
\begin{align*}
	List : * \rightarrow *
\end{align*}
\noindent
The types are introduced through a special type predicate:
\begin{align*}
	TYPEOF : PredRef \times List(*)
\end{align*}
In this way, $TYPEOF$ relates the referenced predicate with a list of types:
\begin{align*}
TYPEOF('A, [t_1, \ldots, t_n]). &\implies A : t_1 \times \ldots \times t_n\\
\end{align*}
\vspace*{-\baselineskip}\vspace*{-\baselineskip}\vspace*{-\baselineskip}
\subsubsection{Type Checking and Type Inference}
Type-checking and left-to-right type inference of a Datalog program $P$ is done through the generation of another datalog program $P_T$. The type checking is performed in three passes. First $P_T$ is generated from $P$. Second, the evaluation of $P_T$ gives the local type information for the terms in each rule. Third, global consistency is checked over the local result. The process is perhaps best illustrated with an example. Consider the source program $P$ in figure \ref{figure:sourceP}. The transformed type program $P_T$ is shown in figure \ref{figure:sourcePT}.
\begin{figure}[!ht]
\begin{minted}{yaml}
TYPEOF('A, [String Integer]).
B(1, 2).
C(x, y, z) :- A(x, y), B(z, z).
D(x, y, z) :- B(x, y), A(z, y).
\end{minted}
\caption{The source program $P$.}
\label{figure:sourceP}
\end{figure}

\begin{figure}[!ht]
\begin{minted}{yaml}
A(String, Integer), B(Integer, Integer).
Typeof(PredRef, List(Type)).
C(x, y, z)     :- A(x, y), B(z, z).
D(x, y, z)     :- B(x, y), A(z, y).
Rule0(x, y, z) :- C(x, y, z), A(x, y), B(z, z).
Rule1(x, y, z) :- D(x, y, z), B(x, y), A(z, y).
\end{minted}
\caption{The transformed type program $P_T$.}
\label{figure:sourcePT}
\end{figure}
\noindent
A new rule predicate $r^{'}_i$ is added to $P_T$ for each rule $r_i$ in $P$. The head of $r^{'}_i$ is given a unique name (in the example $Rule0$, $Rule1$) and has as terms all the variables occurring in $r_i$. The body of $r^{'}_i$ consists of all the atoms in $r_i$. Additionally, the initial type facts are added. This gives the basis for local type-checking. To provide left-to-right type inference, the rules in $P$ are added to $P_T$ as-is. In the example, this allows the derivation of the types for $C$, and $D$. 
The example has a single solution for the rule types:
\begin{align*}
Rule0 : String  \times Integer \times Integer\\
Rule1 : Integer \times Integer \times String
\end{align*}
The rule-type solution gives the \textit{type-environment} $\Gamma$ in which the rule is executed: $\Gamma : Rule \rightarrow Variable \rightarrow *$. Using $\Gamma$, a global pass can trivially check that the type of each atom is unique across all rules.

\subsection{Meta-Predicates}
The language needs a way for the user to communicate certain properties about the datalog-program $P$ to the interpreter $I$.
An example of such a property is what relations to load as EDBs.
In turn, $I$ makes certain information available to $P$ which allows $P$ to make inference on properties of itself.
The information passing is done through a collection of pre-defined atoms. The currently supported such meta-predicates are listed in figure \ref{figure:metaatoms}. As is shown in the table, $EDB$ and $OUTPUT$ pass information from $P$ to $I$, $ATOM$, and $PRED$ pass information from $I$ to $P$. $TYPEOF$ initially provides $I$ with information about the given types. After successful type-checks and possibly type-inference, $I$ makes the result available to $P$, again through $TYPEOF$. In this way, $TYPEOF$ is a bi-directional predicate. Figures \ref{figure:outputatom}, \ref{figure:edb} show two examples of possible usages for the meta-predicates.

\begin{figure}[!ht]
	\begin{adjustwidth}{-0.5cm}{}
\begin{tabular}{ | c | c | c | }
	\hline
    \textbf{Predicate}  & \textbf{ Type } & \textbf{Semantics}\\
	\hline
    \multicolumn{3}{|c|}{\textbf{Datalog Program $\rightarrow$ Interpreter}}\\
    % \multicolumn{3}{|c|}{}\\
	\hline
	$EDB$  & $PredRef \times String$ & \makecell{$('A, s) \in EDB$ \\ Tuples in file $s$ loaded into $A$} \\
	\hline
	$OUTPUT$ & $PredRef$ & \makecell{$('A) \in OUTPUT$ \\ Tuples in $A$ printed to ''$A$.csv''} \\
	\hline
    \multicolumn{3}{|c|}{\textbf{Datalog Program $\leftarrow$ Interpreter}}\\
    % \multicolumn{3}{|c|}{}\\
	\hline 
	$ATOM$ & $PredRef$ & \makecell{$('A) \in ATOM$\\ $A$ is a user-defined atom.} \\
	\hline
	$PRED$ & $PredRef$ & \makecell{$('A) \in PRED$\\ $A$ is any occurring atom.} \\
	\hline 
    \multicolumn{3}{|c|}{\textbf{Datalog Program $\leftrightarrow$ Interpreter}}\\
    % \multicolumn{3}{|c|}{}\\
	\hline 
    $TYPEOF$ & $PredRef \times List(*)$ & \makecell{$('A, [t_1,\ldots, t_n]) \in TYPEOF$\\ $A : t_1 \times \ldots \times t_n$.} \\
	\hline
\end{tabular}
\end{adjustwidth}
\caption{A list of supported meta-predicates. The semantics column shows an if-and-only-if relation between the upper and lower statements.}
\label{figure:metaatoms}
\end{figure}

\begin{figure}[!ht]
\begin{minipage}{4cm}
\begin{minted}{yaml}
OUTPUT('OUTPUT).
OUTPUT(x) :- ATOM(x). 
\end{minted}
\end{minipage}
\vspace*{-10pt}
\caption{Printout all user defined-atoms as well as the $OUTPUT$-relation.}
\label{figure:outputatom}
\end{figure}

\vspace*{-\baselineskip}
\begin{figure}[!ht]
\begin{minipage}{4cm}
\begin{minted}{yaml}
EDB('EDB, "EDB.csv"). 
\end{minted}
\end{minipage}
\vspace*{-10pt}
\caption{Load the tuples that describe what to load as EDB files from the external database file EDB.csv}
\label{figure:edb}
\end{figure}
