import lang.ast.Program;
import lang.ast.StandardPrettyPrinter;
import lang.ast.SoufflePrettyPrinter;
import lang.ast.FormalPredicate;
import lang.ast.Literal;
import lang.io.FileUtil;
import lang.io.CSVUtil;
import lang.io.SimpleLogger;
import lang.Compiler;
import lang.evaluation.BottomUpNaiveIterative;
import java.util.Set;
import java.util.HashSet;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.FileReader;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;

aspect Configuration {
    syn String Description.inputFile() = getInput().getPath();
    syn String Description.inputFileName() {
        return FileUtil.fileName(inputFile());
    }
    syn String Description.outputDir() = getTask().outputDir();
    syn String Description.factsDir() = getTask().factsDir();

    syn String Task.outputDir() {
        for(ConfigParam param : getParamss()) {
            if(param.isOutputDir())
                return FileUtil.normalize(((OutputDir) param).getPath());
        }
        return System.getProperty("user.dir");
    }

    syn String Task.factsDir() {
        for(ConfigParam param : getParamss()) {
            if(param.isFactsDir())
                return FileUtil.normalize(((FactsDir) param).getPath());
        }
        return System.getProperty("user.dir");
    }

    syn boolean ConfigParam.isOutputDir()  = false;
    syn boolean OutputDir.isOutputDir()    = true;

    syn boolean ConfigParam.isFactsDir()   = false;
    syn boolean FactsDir.isFactsDir()      = true;
}

aspect SouffleConfiguration {
    syn boolean SouffleParam.isOutputFileName()   = false;
    syn boolean OutputFileName.isOutputFileName() = true;

    inh String SouffleTask.inputFileName();
    eq Description.getChild().inputFileName() = inputFileName();

    syn String SouffleTask.outputFileName() {
        for(SouffleParam param : getSouffleSpecificParamss()) {
            if(param.isOutputFileName())
                return ((OutputFileName) param).getName();
        }
        return FileUtil.changeExtension(inputFileName(), ".dl");
    }
}

aspect Task {
    public abstract Program Task.perform() throws Exception;
    inh Description Task.description();
    eq Description.getChild().description() = this;

    public Program Task.getProgramWithChecks() throws Exception {
        Program program = (Program) FileUtil.parse(new File(description().getInput().getPath()));
        Compiler.DrAST_root_node = program; // Enable debugging with DrAST
        new SemanticCheck(getParamss()).perform(program, description());
        new TypeCheck(getParamss()).perform(program, description());
        return program;
    }
}

aspect Internal {
    public Program EvalBottomUpNaive.perform()  throws Exception {
        SimpleLogger.logger().log(description().debugInfo(), SimpleLogger.LogLevel.Level.DEBUG);
        Program program = getProgramWithChecks();
        BottomUpNaiveIterative bit = new BottomUpNaiveIterative();
        bit.evaluate(program, description());
        return program;
    }

    public Program PrettyBottomUpNaive.perform()  throws Exception {
        Program program = (Program) FileUtil.parse(new File(description().getInput().getPath()));
        Compiler.DrAST_root_node = program; // Enable debugging with DrAST
        StandardPrettyPrinter spp = new StandardPrettyPrinter<Program>(new PrintStream(System.out));
        spp.prettyPrint(program);
        return program;
    }
}

aspect Souffle {
    protected Program SouffleTask.preEvaluate(HashSet<File> copied, HashSet<File> moved) throws Exception {
        SimpleLogger.logger().log(description().debugInfo(), SimpleLogger.LogLevel.Level.DEBUG);
        File tmp_dir_1 = new File("tmp/tmp1");
        File tmp_dir_2 = new File("tmp/tmp2");
        tmp_dir_1.mkdirs();
        tmp_dir_2.mkdirs();
        String source_eval = "eval::bottomupnaive -OUT " + tmp_dir_1.getPath() + " -FACTS " + factsDir() + " " + description().inputFile();
        Description evalDescr = FileUtil.parseDescription(source_eval);
        Program program = evalDescr.getTask().perform();

        HashSet<String> visited = new HashSet<String>();
        for(Literal l : program.predefinedLiterals()) {
            FormalPredicate fp = l.predicate().formalpredicate();
            if(visited.contains(fp.predicateName())) continue;
            visited.add(fp.predicateName());
            File output_fp = new File(factsDir() + "/" + fp.predicateName() + ".csv");
            if(output_fp.exists() && !output_fp.isDirectory()) {
                SimpleLogger.logger().log("Move: " + output_fp.getPath() + " from  " + factsDir() + " to " + tmp_dir_2.getPath(),
                        SimpleLogger.LogLevel.Level.DEBUG);
                File mv_file = new File(tmp_dir_2.getPath() + "/" + output_fp.getName());
                Files.move(output_fp.toPath(), mv_file.toPath(), StandardCopyOption.REPLACE_EXISTING);
                moved.add(mv_file);
            } else 
                copied.add(output_fp);
            CSVUtil.dumpFileInto(fp, output_fp);
        }
        return program;
    }

    protected void SouffleTask.postEvaluate(HashSet<File> copied, HashSet<File> moved) throws Exception { 
        for(File fp : copied) {
            SimpleLogger.logger().log("Delete: " + fp.getName(), SimpleLogger.LogLevel.Level.DEBUG);
            fp.delete();
        }

        for(File fp : moved) {
            SimpleLogger.logger().log("Move Back: " + fp.getName(), SimpleLogger.LogLevel.Level.DEBUG);
            Files.move(fp.toPath(), new File(factsDir() + "/" + fp.getName()).toPath(), StandardCopyOption.REPLACE_EXISTING);
        }
    }

    public Program EvalSouffle.perform()  throws Exception {
        HashSet<File> copied = new HashSet<File>();
        HashSet<File> moved  = new HashSet<File>();
        Program program;
        try {
            program = preEvaluate(copied, moved);
            String soufflePath = outputDir() + "/" + outputFileName();
            SimpleLogger.logger().log("PrettyPrint to: " + soufflePath, SimpleLogger.LogLevel.Level.DEBUG);
            program.soufflePrint(new SoufflePrettyPrinter<Program>(new PrintStream(new FileOutputStream(new File(soufflePath)))));

            String cmd = "souffle -D " + outputDir() + " " + soufflePath + " -F " + factsDir();
            SimpleLogger.logger().log("Run souffle with: " + cmd, SimpleLogger.LogLevel.Level.DEBUG);

			long start = System.nanoTime();
            Process p = Runtime.getRuntime().exec(cmd);
            p.waitFor();
            long end = System.nanoTime();
		    double elapsed = (end - start) / 1000000;
		    System.out.print(elapsed);

            BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
            while (br.ready())
                SimpleLogger.logger().log(":SOUFFLE-OUTPUT " + br.readLine(), SimpleLogger.LogLevel.Level.DEBUG);
            BufferedReader brerr = new BufferedReader(new InputStreamReader(p.getErrorStream()));
            while (brerr.ready())
                SimpleLogger.logger().log(":SOUFFLE-ERROR " + brerr.readLine(), SimpleLogger.LogLevel.Level.ERROR);

            br.close();
            brerr.close();
        } finally {
            postEvaluate(copied, moved);
        }
        return program;
    }

    public Program PrettySouffle.perform()  throws Exception{
        HashSet<File> copied = new HashSet<File>();
        HashSet<File> moved  = new HashSet<File>();
        Program program;
        try {
            program = preEvaluate(copied, moved);
            program.soufflePrint(new SoufflePrettyPrinter<Program>(new PrintStream(System.out)));
        } finally {
            postEvaluate(copied, moved);
        }
        return program;
    }
}

aspect TypeProg {
    public Program TypeProg.perform()  throws Exception{
        Program program = (Program) FileUtil.parse(new File(description().getInput().getPath()));
        new SemanticCheck(getParamss()).perform(program, description());
        String typeProgSource = program.typePrint();
        System.out.println("------------------------------------------------");
        System.out.println("\t\t\t TYPESOURCE");
        System.out.println("------------------------------------------------");
        System.out.println(typeProgSource);
        System.out.println("------------------------------------------------");

        Program typeProg = FileUtil.parse(typeProgSource);
        BottomUpNaiveIterative eval = new BottomUpNaiveIterative();
        eval.evaluate(typeProg, null);

        System.out.println("------------------------------------------------");
        System.out.println("\t\t\t EVAL RESULT");
        System.out.println("------------------------------------------------");
        for(FormalPredicate fp : typeProg.getFormalPredicates()) {
            System.out.println(fp.predicateName() + ": " + fp.relation);
        }

        System.out.println("------------------------------------------------");
        new TypeCheck(getParamss()).perform(program, description());

        System.out.println("------------------------------------------------");
        System.out.println("\t\t\t TYPEINFERENCE RESULT");
        System.out.println("------------------------------------------------");
        for(FormalPredicate fp : program.getFormalPredicates()) {
            if(fp.literal().isInclusive())
                System.out.println(fp.predicateName() + ": " + fp.derivedTypes());
        }
        System.out.println("------------------------------------------------");
        return program;
    }
}

aspect SubTask {
    public Program TypeCheck.perform()  throws Exception {
        Program program = (Program) FileUtil.parse(new File(description().getInput().getPath()));
        Compiler.DrAST_root_node = program; // Enable debugging with DrAST
        perform(program, description());
        return program;
    }
    public Program SemanticCheck.perform()  throws Exception {
        Program program = (Program) FileUtil.parse(new File(description().getInput().getPath()));
        Compiler.DrAST_root_node = program; // Enable debugging with DrAST
        perform(program, description());
        return program;
    }

    public interface SubTask {
        void perform(Program program, Description descr) throws Exception;
    }

    TypeCheck       implements SubTask;
    SemanticCheck   implements SubTask;
    public void TypeCheck.perform(Program program, Description descr) throws Exception {
        program.typeCheck();
        Set<String> terrs = program.typeCheckErrors();
        if (!terrs.isEmpty()) {
            SimpleLogger.logger().log("Compilation failed with the following error messages: ", SimpleLogger.LogLevel.Level.ERROR);
            for(String err : terrs)  SimpleLogger.logger().log(err);
            System.exit(0);
        }
    }

    public void SemanticCheck.perform(Program program, Description descr) throws Exception {
        Set<String> serrs = program.semanticErrors();
        if (!serrs.isEmpty()) {
            SimpleLogger.logger().log("Compilation failed with the following error messages: ", SimpleLogger.LogLevel.Level.ERROR);
            for(String err : serrs)  SimpleLogger.logger().log(err);
            System.exit(0);
        }
    }
}
