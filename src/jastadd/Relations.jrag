import java.util.HashSet;
import java.util.HashMap;
import java.util.TreeSet;
import java.util.Comparator;
import lang.relation.Relation;
import lang.relation.PseudoTuple;

aspect Arity {
    syn int Literal.arity();
    eq NEGLiteral.arity() = 1;
    eq EDBLiteral.arity() = 2;
    eq Atom.arity() = getNumTerms();
    syn int PredicateSymbol.arity() = literal().arity();
    
    syn HashSet<Integer> FormalPredicate.arities() {
    	HashSet<Integer> arities = new HashSet<Integer>();
    	for(PredicateSymbol pred : predicates()) {
            if(!pred.isTerm())
            	arities.add(pred.arity());
        }
        return arities;
    }
    
    syn HashSet<Integer> FormalPredicate.realArities() {
        HashSet<Integer> realArities = new HashSet<Integer>(arities());
        realArities.remove(-1);
        return realArities;
    }
    
    syn boolean FormalPredicate.isUniqueArity() {
        return realArities().size() <= 1;
    }

    syn int FormalPredicate.realArity() {
        if(!isUniqueArity() || realArities().size() == 0) return 0;
        return realArities().iterator().next();
    }
    
   // FormalPredicate contributes ("Different Arities for predicate symbol: " + predicateName())
   //     when !uniqueArity() && arities().size() != 1
   //     to Program.semanticErrors();
}

aspect Relation {
	public Relation FormalPredicate.relation;
	
	syn Relation FormalPredicate.fileRelation() {
		Relation r = new Relation(realArity());
		for(PredicateSymbol pred : predicates()) {
			if(pred.isFact() && pred.isAtom()) {
				r.addTuple(new PseudoTuple((Atom)pred.literal()));
			}
		}
		return r;
	}
}

aspect Rules {
	syn HashSet<Rule> FormalPredicate.useInRules() {
		HashSet<Rule> rules = new HashSet<Rule>();
		for(PredicateSymbol pred : predicates()) {
			if(pred.isUse()) {
				rules.add((Rule)pred.literal().clause());
			}
		}
		return rules;
	}

	syn HashSet<Rule> FormalPredicate.definedInRules() {
		HashSet<Rule> rules = new HashSet<Rule>();
		for(PredicateSymbol pred : predicates()) {
			if(pred.isDef()) {
				rules.add((Rule)pred.literal().clause());
			}
		}
		return rules;
	}
}

aspect DependencyGraph {
	syn HashSet<FormalPredicate> FormalPredicate.dependsOn() {
		HashSet<FormalPredicate> rules = new HashSet<FormalPredicate>();
		for(Rule r : definedInRules()) {
			for(Literal l : r.getBodys()) {
				if(l.predicate().isNeg()) {
					NEGLiteral nl = (NEGLiteral)l;
					rules.add(nl.getFormalLiteral().predicate().formalpredicate());
				}else {
					rules.add(l.predicate().formalpredicate());
				}
			}
		}
		
		for(PredicateSymbol pred : predicates()) {
			if(pred.isInEDB() && !pred.isEDB()) {
				rules.add(pred.literal().predicate().formalpredicate());
				break;
			}
		}
		return rules;
	}	
}
/*
aspect Proof {
	syn boolean Program.mayProve(PseudoTuple t) {
		if(!t.isGround()) return false;
		for(int i = 0; i != t.size; ++i) {
			Constant c = (Constant)t.coord(i);
			if(!objects.contains(c)) return false;
		}
		return true;
	}
}
*/