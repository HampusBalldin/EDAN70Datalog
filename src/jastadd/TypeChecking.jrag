import lang.io.FileUtil;
import lang.evaluation.BottomUpNaiveIterative;
import java.util.Collections;
import lang.relation.Instantiation;
aspect TypeChecking {
	 public HashMap<Rule, Instantiation> Program.instantMap = new HashMap<Rule, Instantiation>();
	 public void Program.typeCheck() throws IOException, beaver.Parser.Exception {
	 	String typeProgSource = typePrint();
	 	SimpleLogger.logger().log("TypeProg:\n" + typeProgSource, SimpleLogger.LogLevel.Level.DEBUG);
	 	Program typeProg = FileUtil.parse(typeProgSource);
	 	BottomUpNaiveIterative eval = new BottomUpNaiveIterative();
	 	eval.evaluate(typeProg, null);
	 	
	 	boolean typeError = false;
	 	for(FormalPredicate fp : typeProg.getFormalPredicates()) {
	 		if(fp.predicateName().startsWith(GlobalNames.TYPE_RULE_NAME)) {
	 			SimpleLogger.logger().log(fp.predicateName() + ": " + fp.relation, SimpleLogger.LogLevel.Level.DEBUG);
	 			
	 			if(fp.relation.size() == 0 || fp.relation.size() > 1) {
	 				typeError = true;
	 				TreeSet<String> affectedClauses = new TreeSet<String>();
	 				for(Literal l : ((Rule)fp.literal().clause()).getBodys()) {
	 					if(l.isInclusive())
	 						affectedClauses.add(l.predicate().getPRED_ID());
	 				}
	 				if(fp.relation.size() == 0)
	 					SimpleLogger.logger().log("Not enough type information at: " + affectedClauses, SimpleLogger.LogLevel.Level.ERROR);
	 				else
	 					SimpleLogger.logger().log("Contradictory type information at: " + affectedClauses, SimpleLogger.LogLevel.Level.ERROR);
	 			}
	 		}
	 	}
	 	
	 	if(typeError) System.exit(0);
	 	for(FormalPredicate fp : typeProg.getFormalPredicates()) {
	 		if(fp.predicateName().startsWith(GlobalNames.TYPE_RULE_NAME)) {
	 			Rule r = (Rule)fp.literal().clause();
	 			int index = Integer.parseInt(fp.predicateName().substring(GlobalNames.TYPE_RULE_NAME.length()));
	 			System.out.println(fp.predicateName() + " -> " + index + " -> " + getClause(index));
	 			System.out.println(r.variables());
	 			System.out.println(fp.relation.tuples().iterator().next());
	 			
	 			PseudoTuple var_tuple = new PseudoTuple(r.variables());
	 			PseudoTuple type_tuple = fp.relation.tuples().iterator().next();
	 			Instantiation inst = new Instantiation(var_tuple, type_tuple);
	 			System.out.println(inst);
	 			
	 			instantMap.put((Rule)getClause(index), inst);
	 		}
	 	}
	 }
	 
	 /*
	coll MapToSetOf<String, ConstraintEntry> Rule.typeConstraintMap() [new MapToSetOf(new TreeSetConstructor(null))] with add;
	Variable contributes new MapEntry(toString(), new ConstraintEntry(occuresIn().predicate().formalpredicate(), index()))
		when !isNested() //&& occuresIn().isAtom()
		to Rule.typeConstraintMap()
		for occuresIn().clause();
	*/
	/*
	syn Set<MapEntry<Integer, Type>> PredefinedLiteral.predefinedTypeContribution() {
		HashSet<MapEntry<Integer, Type>> type_binding = new HashSet<MapEntry<Integer, Type>>();
		for(int i = 0; i != type().arity(); ++i)
			type_binding.add(new MapEntry(i, (Type)type().coord(i)));
		return type_binding;
	}
	
	
	syn boolean PredefinedLiteral.satisfiedType() {
		if(type().arity() != actualType().arity()) return false;
		for(int i = 0; i != type().arity(); ++i) {
			Type t1 = (Type)type().coord(i);
			Type t2 = (Type)actualType().coord(i);
			if(t2.isVariableType()) continue;
			if(Type.typeComparator.compare(t1, t2) != 0) return false;
		}
		return true;
	}
	
	syn boolean FormalPredicate.hasContradictingType() {
   		for(Integer coord : coordTypeMap().keySet()) 
   			if(coordTypeMap().get(coord).size() > 1) return true;
   		return false;
    }
	
   Program contributes nta getFormalPredicateList() to Program.semanticErrors();
   FormalPredicate contributes "Contradictory type for predicate: " + predicateName()
   		when hasContradictingType()
   		to Program.semanticErrors();
   		
   	syn String PredefinedLiteral.typeErrorMsg() = "Expected: " + type() + " but got: " + actualType() + " for " + predicate().getPRED_ID();
    OUTPUTLiteral contributes typeErrorMsg() when !satisfiedType() to Program.semanticErrors();
    ATOMLiteral   contributes typeErrorMsg() when !satisfiedType() to Program.semanticErrors();
    EDBLiteral    contributes typeErrorMsg() when !satisfiedType() to Program.semanticErrors();
    PREDLiteral   contributes typeErrorMsg() when !satisfiedType() to Program.semanticErrors();
    TYPEOFLiteral contributes typeErrorMsg() when !satisfiedType() to Program.semanticErrors();
    Expr          contributes "Contradicting type in: " + this when hasContradictingType() to Program.semanticErrors();
    TermList      contributes "Bad Type in list: "      + this when !isWellTyped() to Program.semanticErrors();
    BinaryExclusiveTermLiteral contributes "Contradicting type in: " + this when hasContradictingType() to Program.semanticErrors();
	
	syn boolean BinaryExclusiveTermLiteral.hasContradictingType() {
		TreeSet<Type> types = new TreeSet<Type>(Type.typeComparator);
		TreeSet<Constant> constants = new TreeSet<Constant>(Term.termComparator);
		constants.addAll(getLeft().constants());
		constants.addAll(getRight().constants());
		for(Constant c : constants) {
			types.add(c.type());
			if(types.size() > 1) return true;
		}
		return false;
	}
	
	syn boolean Expr.hasContradictingType() {
		TreeSet<Type> types = new TreeSet<Type>(Type.typeComparator);
		for(Constant c : constants()) {
			types.add(c.type());
			if(types.size() > 1) return true;
		}
		return false;
	}
		
	coll MapToSetOf<Integer, Type> FormalPredicate.coordTypeMap() [new MapToSetOf(new HashSetConstructor())] with addAll;
	Term contributes Collections.singleton(new MapEntry(index(), type()))
        when !isNested() && isConstant() && occuresIn().isAtom()
        to FormalPredicate.coordTypeMap()
        for occuresIn().predicate().formalpredicate();
    
    OUTPUTLiteral contributes predefinedTypeContribution() to FormalPredicate.coordTypeMap() for predicate().formalpredicate();
    ATOMLiteral   contributes predefinedTypeContribution() to FormalPredicate.coordTypeMap() for predicate().formalpredicate();
    EDBLiteral    contributes predefinedTypeContribution() to FormalPredicate.coordTypeMap() for predicate().formalpredicate();
    PREDLiteral   contributes predefinedTypeContribution() to FormalPredicate.coordTypeMap() for predicate().formalpredicate();
    */
}
