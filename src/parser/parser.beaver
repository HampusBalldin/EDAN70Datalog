%class "LangParser";
%package "lang.ast";

%embed {:
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}
:};

%terminals VAR_ID, PRED_ID, PRED_REF, LPARA, RPARA, NUMERAL, STRING, DOT, COMMA, IMPLIED_BY, EDB, NOT, EQ, NEQ, LT, LTE, GT, GTE;

%typeof  program             =  "Program";
%typeof  clause              =  "Clause";
%typeof  literal             =  "Literal";
%typeof  inclusive_literal   =  "InclusiveLiteral";
%typeof  exclusive_literal   =  "ExclusiveLiteral";
%typeof  bin_excl_term_lit   =  "BinaryExclusiveTermLiteral";
%typeof  edb_literal         =  "EDBLiteral";
%typeof  neg_literal         =  "NEGLiteral";
%typeof  eq_literal          =  "EQLiteral";
%typeof  neq_literal         =  "NEQLiteral";
%typeof  lt_literal          =  "LTLiteral";
%typeof  lte_literal         =  "LTELiteral";
%typeof  gt_literal          =  "GTLiteral";
%typeof  gte_literal         =  "GTELiteral";
%typeof  atom                =  "Atom";
%typeof  pred_sym            =  "PredicateSymbol";
%typeof  pred_ref            =  "PredicateRef";
%typeof  variable            =  "Variable";
%typeof  constant            =  "Constant";
%typeof  int_constant        =  "IntConstant";
%typeof  string_constant     =  "StringConstant";
%typeof  term                =  "Term";
%typeof  term_list           =  "List";
%typeof  term_list_no_empty  =  "List";
%typeof  lit_list            =  "List";
%typeof  incl_lit_list       =  "List";
%typeof  clause_list         =  "List";
%typeof  fact                =  "Fact";
%typeof  rule                =  "Rule";

%goal program;

program =  clause_list.list {: return new Program(list); :};
clause_list = clause.c {: return new List().add(c); :}
            | clause_list.list clause.c {: return list.add(c); :}
            ;

clause = rule
       | fact
       ;

rule = incl_lit_list.heads IMPLIED_BY lit_list.body DOT {: return new Rule(heads, body); :};
fact = incl_lit_list.heads DOT {: return new Fact(heads); :};


literal = inclusive_literal
        | exclusive_literal
        ;
        
inclusive_literal = edb_literal
			      | atom
			      ;
			  
exclusive_literal = neg_literal
                  | bin_excl_term_lit
             	  ;
             	  
bin_excl_term_lit = eq_literal
                  | neq_literal
                  | lt_literal
                  | lte_literal
                  | gt_literal
                  | gte_literal
                  ;

eq_literal  = EQ  LPARA term.left COMMA term.right RPARA {: return new EQLiteral(new PredicateSymbol("EQ"), left, right); :};
neq_literal = NEQ LPARA term.left COMMA term.right RPARA {: return new NEQLiteral(new PredicateSymbol("NEQ"), left, right); :};
lt_literal  = LT  LPARA term.left COMMA term.right RPARA {: return new LTLiteral(new PredicateSymbol("LT"), left, right); :};
lte_literal = LTE LPARA term.left COMMA term.right RPARA {: return new LTELiteral(new PredicateSymbol("LTE"), left, right); :};
gt_literal  = GT  LPARA term.left COMMA term.right RPARA {: return new GTLiteral(new PredicateSymbol("GT"), left, right); :};
gte_literal = GTE LPARA term.left COMMA term.right RPARA {: return new GTELiteral(new PredicateSymbol("GTE"), left, right); :};

atom = pred_sym.pred LPARA term_list.terms RPARA {: return new Atom(pred, terms); :};

edb_literal = EDB LPARA pred_ref.pred COMMA term.filelocs RPARA {: return new EDBLiteral(new PredicateSymbol("EDB"), pred, filelocs); :};

neg_literal = NOT LPARA inclusive_literal.lit RPARA {: return new NEGLiteral(new PredicateSymbol("NOT"), lit); :};

lit_list = literal.lit {: return new List().add(lit); :}
         | lit_list.list COMMA literal.c {: return list.add(c); :}
         ;
         
incl_lit_list = inclusive_literal.lit {: return new List().add(lit); :}
         | incl_lit_list.list COMMA inclusive_literal.lit {: return list.add(lit); :}
         ;

term_list = term_list_no_empty
          | /* epsilon */ {: return new List(); :}
          ;

term_list_no_empty = term.t {: return new List().add(t); :}
                   | term_list_no_empty.list COMMA term.t {: return list.add(t); :} 
                   ;
                   
term = variable
     | constant
     | pred_ref
     ;
     
pred_sym = PRED_ID.id  {: return new PredicateSymbol(id); :};
pred_ref = PRED_REF.id {: return new PredicateRef(id); :};
     
variable = VAR_ID.id {: return new Variable(id); :};
constant = int_constant
         | string_constant
         ;

int_constant = NUMERAL.num {: return new IntConstant(num); :};
string_constant = STRING.str {: return new StringConstant(str); :};
