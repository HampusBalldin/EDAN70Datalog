\documentclass{beamer}
\usepackage{forest}
\usepackage{proof}
\usepackage{minted}
\usepackage{makecell}
\usepackage{changepage}
\newcommand{\NL}[0]{ \hfill\\\noindent }
\newcommand{\coloneqtwo}{\mathbin{:\hspace{-0.5ex}\textsf{-}}}

\newcommand{\strconst}[1]{ \colorbox{green!10}{#1} }
\newcommand{\predconst}[1]{ \colorbox{blue!10}{#1} }
\newcommand{\intconst}[1]{ \colorbox{cyan!10}{#1} }
\newcommand{\listconst}[1]{ \colorbox{orange!10}{#1} }
\newcommand{\typeconst}[1]{ \colorbox{red!10}{#1} }
\begin{document}	
\begin{frame}
% \frametitle{Datalog - Recursive Query Processing}

\begin{center}
	\Huge Datalog - Recursive Query Processing
\end{center}
%Content goes here
\end{frame}
\begin{frame}
\frametitle{The core Datalog language}
%\framesubtitle{A bit more information about this}
A program is a set of \textit{Horn Clauses}.\NL
\begin{align*}
Ancestor(a, c) \coloneqtwo Parent(p, c), Ancestor(a, p).
\end{align*}
\begin{itemize}
\item<2-> \fbox{$Ancestor(a, c) \coloneqtwo Parent(p, c), Ancestor(a, p).$} \hfill Horn Clause
\item<3-> $\fbox{Ancestor(a, c)} \coloneqtwo \fbox{Parent(p, c), Ancestor(a, p)}.$ \hfill Head, Body
\item<4-> \fbox{$Ancestor(a, c)$} \hfill Atom
\item<5-> \fbox{$Ancestor$}(\fbox{$a, c$}) \hfill Predicate, List of Terms
\end{itemize}
\NL
\uncover<6->{Semantics: $Body \implies Head$ \quad}
%More content goes here
\end{frame}

\begin{frame}
\frametitle{EDBs and IDBs}
\begin{itemize}
\item<2-> \textbf{EDB: } Extensional database, explicitly defines predicates through facts.
\item<4-> \textbf{IDB: } Intensional database, implicitly defines predicates through rules (Horn Clauses) showing intent.
\end{itemize}
\NL
\uncover<3,6>{$Parent("Eddard", "Arya").$}\NL
\uncover<3,6>{$Parent("Lyarra", "Eddard").$}\NL
\NL
\uncover<5-6>{$Ancestor(p, c) \coloneqtwo Parent(p, c).$}\NL
\uncover<5-6>{$Ancestor(a, c) \coloneqtwo Parent(p, c), Ancestor(a, p).$}
\end{frame}

\begin{frame}
\frametitle{Fix-point Iteration}
\begin{itemize}
	\item<2-> Begin with the EDB facts: $I^0$.
	\item<3-> Use rules to derive IDB facts. 
	\item<4-> In iteration $i$ the set of new facts derived from current facts $I^i$ are $\Delta_i$
	\item<5->  $I^{i + 1} = I^{i} \cup \Delta_i$
	\item<6->  Iterate until $I^{n+1} = I^n$
	\item<7->  Guaranteed termination with finite EDBs!
\end{itemize}
%	\item<7->  \textbf{Naive evaluation}: use $I^{i + 1}$ as input to each iteration.
%\item<7->  \textbf{Semi-Naive evaluation}: use $\Delta_i$ as input to each iteration.
%Naive evaluation is less efficient than semi-naive evaluation

\end{frame}

\begin{frame}
\frametitle{Fix-point Iteration}
\framesubtitle{Example continued}
\uncover<2->{EDBs:}\NL
\uncover<1-2>{$Parent(\strconst{"Eddard"}, \strconst{"Arya"}).$}\NL
\uncover<1-2>{$Parent(\strconst{"Lyarra"}, \strconst{"Eddard"}).$}\NL
\NL
\uncover<1-1>{$Ancestor(p, c) \coloneqtwo Parent(p, c).$}\NL
\uncover<1-1>{$Ancestor(a, c) \coloneqtwo Parent(p, c), Ancestor(a, p).$}

\uncover<2->{
Database $I^0$:\NL\NL
\begin{tabular}{ | c | c | }
	\hline
	\multicolumn{2}{|c|}{\textbf{Parent}}\\
	\hline
	\textbf{p}  & \textbf{ c }\\
	\hline
	\strconst{"Eddard"}  & \strconst{"Arya"}\\
	\hline
	\strconst{"Lyarra"}  & \strconst{"Eddard"}\\
	\hline
\end{tabular}
\begin{tabular}{ | c | c | }
	\hline
	\multicolumn{2}{|c|}{\textbf{Ancestor}}\\
	\hline
	\textbf{a}  & \textbf{ c }\\
	\hline
\end{tabular}
}

\end{frame}

\begin{frame}
\frametitle{Fix-point Iteration}
\framesubtitle{Example continued}
\uncover<1->{
	Database $I^0$:\NL\NL
	\begin{tabular}{ | c | c | }
		\hline
		\multicolumn{2}{|c|}{\textbf{Parent}}\\
		\hline
		\textbf{p}  & \textbf{ c }\\
		\hline
		\strconst{"Eddard"}  & \strconst{"Arya"}\\
		\hline
		\strconst{"Lyarra"}  & \strconst{"Eddard"}\\
		\hline
	\end{tabular}
	\begin{tabular}{ | c | c | }
		\hline
		\multicolumn{2}{|c|}{\textbf{Ancestor}}\\
		\hline
		\textbf{a}  & \textbf{ c }\\
		\hline
	\end{tabular}
}
\NL\NL
\uncover<2->{Apply: $Ancestor(p, c) \coloneqtwo Parent(p, c).$}\NL

\uncover<3->{
	Database $I^1$:\NL\NL
	\begin{tabular}{ | c | c | }
		\hline
		\multicolumn{2}{|c|}{\textbf{Parent}}\\
		\hline
		\textbf{p}  & \textbf{ c }\\
		\hline
		\strconst{"Eddard"}  & \strconst{"Arya"}\\
		\hline
		\strconst{"Lyarra"}  & \strconst{"Eddard"}\\
		\hline
	\end{tabular}
	\begin{tabular}{ | c | c | }
		\hline
		\multicolumn{2}{|c|}{\textbf{Ancestor}}\\
		\hline
        \textbf{a}  & \textbf{ c }\\
		\hline
		\strconst{"Eddard"}  & \strconst{"Arya"}\\
		\hline
		\strconst{"Lyarra"}  & \strconst{"Eddard"}\\
		\hline
	\end{tabular}
}

\end{frame}
\begin{frame}
\frametitle{Fix-point Iteration}
\framesubtitle{Example continued}
\uncover<1->{
	Database $I^1$:\NL\NL
\begin{tabular}{ | c | c | }
	\hline
	\multicolumn{2}{|c|}{\textbf{Parent}}\\
	\hline
	\textbf{p}  & \textbf{ c }\\
	\hline
	\strconst{"Eddard"}  & \strconst{"Arya"}\\
	\hline
	\strconst{"Lyarra"}  & \strconst{"Eddard"}\\
	\hline
\end{tabular}
\begin{tabular}{ | c | c | }
	\hline
	\multicolumn{2}{|c|}{\textbf{Ancestor}}\\
	\hline
	\textbf{a}  & \textbf{ c }\\
	\hline
	\strconst{"Eddard"}  & \strconst{"Arya"}\\
	\hline
	\strconst{"Lyarra"}  & \strconst{"Eddard"}\\
	\hline
\end{tabular}
}
\NL\NL
\uncover<2->{Apply: $Ancestor(a, c) \coloneqtwo Parent(p, c), Ancestor(a, p).$}\NL

\uncover<3->{
	Database $I^2$:\NL\NL
	\begin{tabular}{ | c | c | }
		\hline
		\multicolumn{2}{|c|}{\textbf{Parent}}\\
		\hline
		\textbf{p}  & \textbf{ c }\\
		\hline
		\strconst{"Eddard"}  & \strconst{"Arya"}\\
		\hline
		\strconst{"Lyarra"}  & \strconst{"Eddard"}\\
		\hline
	\end{tabular}
	\begin{tabular}{ | c | c | }
		\hline
		\multicolumn{2}{|c|}{\textbf{Ancestor}}\\
		\hline
		\textbf{a}  & \textbf{ c }\\
		\hline
		\strconst{"Eddard"}  & \strconst{"Arya"}\\
		\hline
		\strconst{"Lyarra"}  & \strconst{"Eddard"}\\
		\hline
		\strconst{"Lyarra"}  & \strconst{"Arya"}\\
		\hline
	\end{tabular}
}

\end{frame}
\begin{frame}
\frametitle{Fix-point Iteration}
\framesubtitle{Example continued}
\uncover<1->{
	Database $I^3$:\NL\NL
\begin{tabular}{ | c | c | }
	\hline
	\multicolumn{2}{|c|}{\textbf{Parent}}\\
	\hline
	\textbf{p}  & \textbf{ c }\\
	\hline
	\strconst{"Eddard"}  & \strconst{"Arya"}\\
	\hline
	\strconst{"Lyarra"}  & \strconst{"Eddard"}\\
	\hline
\end{tabular}
\begin{tabular}{ | c | c | }
	\hline
	\multicolumn{2}{|c|}{\textbf{Ancestor}}\\
	\hline
	\textbf{a}  & \textbf{ c }\\
	\hline
	\strconst{"Eddard"}  & \strconst{"Arya"}\\
	\hline
	\strconst{"Lyarra"}  & \strconst{"Eddard"}\\
	\hline
	\strconst{"Lyarra"}  & \strconst{"Arya"}\\
	\hline
\end{tabular}
}
\NL\NL
\uncover<2->{Iterating rules again gives no new tuples. \\A fix-point has been reached.}
\end{frame}

\begin{frame}
\frametitle{Language Extensions}
Extend the expressive power of core Datalog.
\begin{itemize}
\item<2-> Negation: \\
$NOT(ATOM(t_1, \ldots, t_n))$
\item<3-> Expressions and filtering: \\
$A(x, y) \coloneqtwo B(x), C(y), x \leq \intconst{2} * y$
\item<4-> Object Generation with BIND predicate:\\$Person(p), Parent(p, c) \coloneqtwo Person(c), BIND(p, \strconst{"P("} + c + \strconst{")"})$ 
\item<5-> Predicate References: \\
$A('Parent).$
\item<6-> Types: \\
TYPEOF(\predconst{'Parent}, \listconst{[\typeconst{String} \typeconst{String}]})
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Language Extensions}
\framesubtitle{Predicate References}
\uncover<2->{ \fbox{$EDB : PredRef \times String$} }
\begin{itemize}
\item<3->Determine what predicates to load from external resource.
\item<4->Example: $EDB(\predconst{'Parent}, \strconst{"Parent.csv"}).$
\item<5->Example: $EDB(\predconst{'EDB}, \strconst{"EDB.csv"}).$
\end{itemize}

\uncover<6->{\fbox{$OUTPUT : PredRef$} }
\begin{itemize}
\item<7->Determine what predicates to compute and output. 
\item<8->Example: $OUTPUT(\predconst{'Person}). $
\end{itemize}

\uncover<9->{\fbox{$ATOM : PredRef$} }
\begin{itemize}
\item<10->Interpreter populates the ATOM predicate with a predicate reference for each atom in the Datalog program.
\item<11->Example: $OUTPUT(x) \coloneqtwo ATOM(x).$
\end{itemize}
%\uncover<3->{Interpreter populates the ATOM predicate with a predicate reference for each atom in the Datalog program.}
%\begin{itemize}
%\item<1-> Interpreter populates the ATOM predicate with a predicate reference for each atom in the Datalog program.
%\item<2-> To output all atoms: $OUTPUT(x) \coloneqtwo ATOM(x).$
%\item<3-> The $EDB$ predicate is of type $EDB : PredRef \times String$
%\end{itemize}
\end{frame}
\begin{frame}
\frametitle{Language Extensions: Types}
\framesubtitle{Base Types}
\fbox{$TYPEOF$ \uncover<7->{$ : PredRef \times List(Type)$ }}
\begin{itemize}
\item<2-> Semantics:  $TYPEOF('A, [t_1  \ldots  t_n]) \implies A : t_1 \times \ldots \times t_n$
\item<3-> The types are themselves constant terms with type \textit{Type}.
\item<4-> Base Types: $String : Type, Integer : Type, PredRef : Type, Type : Type$
\item<5-> List is a type constructor: $List : Type \rightarrow Type$.
\item<6-> For example,  $List(Integer)$ is the type of a list of integers.
\item<7-> This enables typing of the TYPEOF predicate: $TYPEOF: PredRef \times List(Type)$.
\end{itemize}
%\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Pretty Printing}
Pretty-printing is used to transform 
\end{frame}
% etc
\end{document}
