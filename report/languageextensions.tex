A number of language features have been added in addition to the core Datalog features. Those extensions are listed and briefly described in the following subsections.
\vspace*{-5 pt}
\subsection{Negation}
A common datalog extension is to allow negation ($\neg$) of atoms. However, unrestricted negation introduces semantic issues as the following example illustrates:

\NL
{\centering
	$A(x) \coloneqtwo \neg B(x).\qquad\qquad[r_1]$ \NL
	$B(x) \coloneqtwo \neg A(x).\qquad\qquad[r_2]$\par
}

\NL
There are two issues with the above example. First, no unique minimal model exists: if $r_1$ is evaluated first then $A = \Omega, B = \emptyset$, and if $r_2$ is evaluated first then $A = \emptyset, B = \Omega$. Second, even if a unique minimal model exists, guaranteed termination is lost since negation removes monotonicity (adding tuples to one relation may remove tuples from another). The first issue is addressed by ensuring that all variable terms used in a negated atom are also used in a non-negated (\textit{positive}) atom. Second, we require that each stratum retains the monotonic property, in particular this means that mutual recursive dependencies must be positive.

With the above restrictions, negation becomes a filtering rule; an occurrence of a negated atom within a rule has already been fully evaluated when that rule is considered in a stratum. 

\subsection{Built-in Predicates and Expressions}
Most (if not all) Datalog systems include various built-in predicates for discarding certain results based on some criteria. The current implementation includes the usual binary predicates $=, \neq, \leq, \ldots$. They can be used with expressions over the usual binary operators $+,-,*,/$. To continue with the order example, a relation that picks ordered tuples with elements at least two units apart is shown below:

\NL
{\centering
	$TwoGapOrder(x, y) \coloneqtwo Order(x, y), x \leq y - 2.$ \NL
}

\vspace*{-\baselineskip}
\subsection{Object Creation}
A special bind predicate was introduced to enable creation of new objects. Combined with \textit{aggregates}, such as counting the number of elements in a relation, this is a useful way to let datalog reason about properties of the currently evaluating program. However, the new expressive power may lead to non-terminating programs as the following example for generating the natural numbers illustrates. 

\begin{minted}{yaml}
Nat(0).
Nat(y) :- Nat(x), BIND(y, x + 1).
\end{minted}
\noindent

\subsection{Type System}
The language includes a simple type system. The basic types are:
\begin{align*}
	String : * \quad Integer : *, \quad PredRef : * 
\end{align*}
\noindent
The types are themselves terms and the star means the type of a type (-term). The $PredRef$ type is used to reference predicates and forms the basis for meta-predicates. Last, the type system has a List \textit{type-constructor}, i.e. it is a function from a term of type $*$ that gives another term of type $*$:
\begin{align*}
	List : * \rightarrow *
\end{align*}
\noindent
The types are introduced through a special type predicate:
\begin{align*}
	TYPEOF : PredRef \times List(*)
\end{align*}
In this way, $TYPEOF$ relates the referenced predicate with a list of types:
\begin{align*}
TYPEOF('A, [t_1, \ldots, t_n]). &\implies A : t_1 \times \ldots \times t_n\\
\end{align*}
\vspace*{-\baselineskip}\vspace*{-\baselineskip}\vspace*{-\baselineskip}
\subsubsection{Type Checking and Type Inference}
Type-checking and left-to-right type inference of a Datalog program $P$ is done through the generation of another datalog program $P_T$. The type checking is performed in three passes. First $P_T$ is generated from $P$. Second, the evaluation of $P_T$ gives the local type information for the terms in each rule. Third, global consistency is checked over the local result. The process is perhaps best illustrated with an example. Consider the source program $P$ in figure \ref{figure:sourceP}. The transformed type program $P_T$ is shown in figure \ref{figure:sourcePT}.
\begin{figure}[!ht]
\begin{minted}{yaml}
TYPEOF('A, [String Integer]).
B(1, 2).
C(x, y, z) :- A(x, y), B(z, z).
D(x, y, z) :- B(x, y), A(z, y).
\end{minted}
\caption{The source program $P$.}
\label{figure:sourceP}
\end{figure}
\vspace*{-20pt}
\begin{figure}[!ht]
\begin{minted}{yaml}
A(String, Integer), B(Integer, Integer).
Typeof(PredRef, List(Type)).
C(x, y, z)     :- A(x, y), B(z, z).
D(x, y, z)     :- B(x, y), A(z, y).
Rule0(x, y, z) :- C(x, y, z), A(x, y), B(z, z).
Rule1(x, y, z) :- D(x, y, z), B(x, y), A(z, y).
\end{minted}
\caption{The transformed type program $P_T$.}
\label{figure:sourcePT}
\end{figure}
\noindent
A new rule predicate $r^{'}_i$ is added to $P_T$ for each rule $r_i$ in $P$. The head of $r^{'}_i$ is given a unique name (in the example $Rule0$, $Rule1$) and has as terms all the variables occurring in $r_i$. The body of $r^{'}_i$ consists of all the atoms in $r_i$. Additionally, the initial type facts are added. This gives the basis for local type-checking. To provide left-to-right type inference, the rules in $P$ are added to $P_T$ as-is. In the example, this allows the derivation of the types for $C$, and $D$. 
The example has a single solution for the rule types:
\begin{align*}
Rule0 : String  \times Integer \times Integer\\
Rule1 : Integer \times Integer \times String
\end{align*}
The rule-type solution gives the \textit{type-environment} $\Gamma$ in which the rule is executed: $\Gamma_{Rule} : Variable \rightarrow *$. Using $\Gamma$, a global pass can trivially check that the type of each atom is unique across all rules.

\paragraph{Correctness of Type Algorithm}\NL
For an atom $A$ in the type algorithm, let the corresponding set of tuples be denoted $A_R$. The typing algorithm reports a type error in one of two cases:
\begin{align*}
&\exists A \in PRED.\;\;|A_R| > 1 \quad\quad (1)\\
&\exists A \in PRED.\;\;|A_R| = 0 \quad\quad (2)
\end{align*}
\noindent
A Datalog program $P$ is said to be \textit{well-typed} if:
\begin{align*}
\forall A \in PRED. \;\; |A_R| = 1 \quad\quad (3)
\end{align*}
A rule with two atoms using the same variable name gives a \textit{type constraint};
\begin{align*}
\infer{A[Pos(x, A)] = B[Pos(x, B)]}{\exists Rule\;R.\;\;\ldots, A( \ldots, x, \ldots), \ldots, B(\ldots, x, \ldots), \ldots \in R}
\end{align*}
\noindent
An Atom $A$ is said to have type-inconsistent usages if have type-constraints $A[m] = B[n_1], A[m] = C[n_2], B[n_1] \neq C[n_2]$. We now sketch a proof that the type algorithm detects all type-inconsistent usages.

\paragraph{Proposition: } \textit{A type-inconsistent usage is reported by the type-checking Algorithm}\NL
There exists some atom $A$ with a type-inconsistent usage: $\exists B, C. A[m] = B[n_1], A[m] = C[n_2], B[n_1] \neq C[n_2]$. Assume by contradiction that the algorithm does not report a type error. Then by construction, after the algorithm terminates the algorithm reports that $(3)$ holds. By assumption, $A, B$ and $A, C$ must be related in some rule(s). 

If $A,B,C$ related in the same rule then from $(3)$ the corresponding rule-predicate (from the type algorithm) must get exactly one type. But it will only get populated if $A,B,C$ agree on coordinates $m, n_1, n_2$ which they do not by assumption. The only possibility is for one of $A,B,C$ to be assigned two types which contradicts $(3)$.

Else, $A,B$ and $A,C$ related in two different rules. Again, from $(3)$ both rule-predicates get populated. As in the previous case, this can only happen if $A[m] = B[n_1] = C[n_2]$ (which by assumption is not true), or if one of $A,B,C$ assigned more than one type (which contradicts (3)). 

In any case, we get a contradiction. $\blacksquare$

\subsection{Meta-Predicates}
The language needs a way for the user to communicate certain properties about the datalog-program $P$ to the interpreter $I$.
An example of such a property is what relations to load as EDBs.
In turn, $I$ makes certain information available to $P$ which allows $P$ to make inference on properties about itself.
The information passing is done through a collection of pre-defined atoms. The currently supported meta-predicates is listed in figure \ref{figure:metaatoms}: $EDB$ and $OUTPUT$ pass information from $P$ to $I$, $ATOM$, and $PRED$ pass information from $I$ to $P$. $TYPEOF$ initially provides $I$ with information about the given types. After successful type-checks and possibly type-inference, $I$ makes the result available to $P$, again through $TYPEOF$. In this way, $TYPEOF$ is a bi-directional predicate. Figures \ref{figure:outputatom}, \ref{figure:edb} show two examples of possible usages for the meta-predicates.

Figure \ref{figure:TYPEOF} shows a valid usage of the $TYPEOF$ predicate. The type of $B$ is inferred from the type of the $TYPEOF$ predicate, and the output of $B$ is as shown in figure \ref{figure:TYPEOFOUTPUT}.
\begin{figure}[!ht]
	\begin{minipage}[b]{.5\textwidth}
		\caption{A valid program that uses the $TYPEOF$ information}
		\begin{minted}{text}
		OUTPUT('B).
		B(x, y) :- TYPEOF(x, y).
		\end{minted}
		\label{figure:TYPEOF}
	\end{minipage}
	\begin{minipage}[b]{.5\textwidth}
		\caption{Output ("B.csv") of program in figure \ref{figure:TYPEOF}.}
		\begin{minted}{text}
		'B,[PredRef List(Type)]
		'OUTPUT,[PredRef]
		'TYPEOF,[PredRef List(Type)]
		\end{minted}
		
		\label{figure:TYPEOFOUTPUT}
	\end{minipage}
\end{figure}

\begin{figure}[!ht]
	\begin{adjustwidth}{-0.5cm}{}
\begin{tabular}{ | c | c | c | }
	\hline
    \textbf{Predicate}  & \textbf{ Type } & \textbf{Semantics}\\
	\hline
    \multicolumn{3}{|c|}{\textbf{Datalog Program $\rightarrow$ Interpreter}}\\
    % \multicolumn{3}{|c|}{}\\
	\hline
	$EDB$  & $PredRef \times String$ & \makecell{$('A, s) \in EDB$ \\ Tuples in file $s$ loaded into $A$} \\
	\hline
	$OUTPUT$ & $PredRef$ & \makecell{$('A) \in OUTPUT$ \\ Tuples in $A$ printed to ''$A$.csv''} \\
	\hline
    \multicolumn{3}{|c|}{\textbf{Datalog Program $\leftarrow$ Interpreter}}\\
    % \multicolumn{3}{|c|}{}\\
	\hline 
	$ATOM$ & $PredRef$ & \makecell{$('A) \in ATOM$\\ $A$ is a user-defined atom.} \\
	\hline
	$PRED$ & $PredRef$ & \makecell{$('A) \in PRED$\\ $A$ is any occurring atom.} \\
	\hline 
    \multicolumn{3}{|c|}{\textbf{Datalog Program $\leftrightarrow$ Interpreter}}\\
    % \multicolumn{3}{|c|}{}\\
	\hline 
    $TYPEOF$ & $PredRef \times List(*)$ & \makecell{$('A, [t_1,\ldots, t_n]) \in TYPEOF$\\ $A : t_1 \times \ldots \times t_n$.} \\
	\hline
\end{tabular}
\end{adjustwidth}
\caption{A list of supported meta-predicates. The semantics column shows an if-and-only-if relation between the upper and lower statements.}
\label{figure:metaatoms}
\end{figure}

\begin{figure}[!ht]
\begin{minipage}{4cm}
\begin{minted}{yaml}
OUTPUT('OUTPUT).
OUTPUT(x) :- ATOM(x). 
\end{minted}
\end{minipage}
\vspace*{-10pt}
\caption{Printout all user defined-atoms as well as the $OUTPUT$-relation.}
\label{figure:outputatom}
\end{figure}

\vspace*{-\baselineskip}
\begin{figure}[!ht]
\begin{minipage}{4cm}
\begin{minted}{yaml}
EDB('EDB, "EDB.csv"). 
\end{minted}
\end{minipage}
\vspace*{-10pt}
\caption{Load the tuples that describe what to load as EDB files from the external database file EDB.csv}
\label{figure:edb}
\end{figure}

\subsubsection{Interaction With Stratification}
The $OUTPUT$-predicate determines what predicates to compute and output. Thus every predicate \textit{directly depends} on $OUTPUT$ (see section 2.1). To evaluate a \datalogM program, the relations are first partitioned into strata. The stratum containing the $OUTPUT$-predicate is evaluated first (using the fix-point algorithm) to compute the objects in the $OUTPUT$-relation. The semantics (see figure \ref{figure:metaatoms}) forces each such object to be evaluated and subsequently printed. 

By rooting the reverse post-order search in the strata corresponding to the predicate references in the $OUTPUT$-relation, the resulting order (i.e. sequence of stratum) will contain stratum $S$ if and only if there exists some predicate reference $p$ in the $OUTPUT$-relation such that the stratum of $p$ transitively depends on the $S$:
\begin{align*}
S \text{ is evaluated } \iff \exists\;p \in OUTPUT.\;Strat\;p \xrightarrow{*} S
\end{align*}

The $EDB$-predicate too needs special attention regarding dependencies since it has the side-effect of populating predicates with objects loaded from external data base files. The following two dependency rules exist:
\begin{align*}
&EDB('P,\;\; \_) \implies P \xrightarrow{} EDB\\
&EDB('EDB,\;\; \_) \implies \forall P \in ATOM. \;\;P \xrightarrow{} EDB
\end{align*}

The first rule states that if a predicate is referenced in the $EDB$-relation, then that predicate directly depends on $EDB$. The second rule states that if the $EDB$-relation is self-referential, then all user-defined predicates directly depend on the $EDB$-relation. The current implementation does not support querying the EDB relation or updating it with a variable, e.g. [$EDB(x, "File.csv") \;\coloneqtwo\; OUTPUT(x)$] is disallowed.


