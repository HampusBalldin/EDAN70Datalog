import java.util.HashSet;
import java.util.HashMap;
import java.util.TreeSet;
import lang.io.SimpleLogger;
import java.util.Collections;

aspect Program {
	inh Program Clause.program();
    eq Program.getChild().program() = this;
	eq Program.getChild().hasRecursiveEDB() {
		FormalPredicate fp_edb = formalPredicateMap().get(GlobalNames.EDB_NAME);
		if(fp_edb == null) return false;
		for(PredicateSymbol ps : fp_edb.predicates()) {
			EDBLiteral lit = (EDBLiteral) ps.literal();
			if(lit.getPredicateRef().getPRED_ID().equals(GlobalNames.EDB_NAME)) return true;
		}
		return false;
	}
	
	coll HashSet<PredicateInterface> Program.predicateSymbols() [new HashSet<PredicateInterface>()] with add;
    PredicateSymbol contributes this
        when true
        to Program.predicateSymbols();
       
    PredicateRef contributes this
        when true
        to Program.predicateSymbols();
        
    syn TreeSet<PredicateInterface> Program.uniquePredicateSymbols() {
        TreeSet<PredicateInterface> uniquePredicateSymbols = new TreeSet<PredicateInterface>(Program.predicateComparator);
        uniquePredicateSymbols.addAll(predicateSymbols());
        return uniquePredicateSymbols;
    }
    
    syn HashMap<String, HashSet<PredicateInterface>> Program.predicateMap() {
        HashMap<String, HashSet<PredicateInterface>> predicateMap = new HashMap<String, HashSet<PredicateInterface>>();
        for(PredicateInterface pred : uniquePredicateSymbols())
            predicateMap.put(pred.getPRED_ID(), new HashSet<PredicateInterface>());
        for(PredicateInterface pred : predicateSymbols()) 
            predicateMap.get(pred.getPRED_ID()).add(pred);
        return predicateMap;
    }
    
    public class FormalPredicateMap extends HashMap<String, FormalPredicate> {
    	public void add(MapEntry<String, FormalPredicate> me) { put(me.k, me.v); }
    }
    public class MapEntry<Key, Value> {
    	public Key k;
    	public Value v;
    		
    	public MapEntry(Key k, Value v) {
    		this.k = k;
    		this.v = v;
    	}
    }
    
    coll FormalPredicateMap Program.formalPredicateMap() [new FormalPredicateMap()] with add;
    Program contributes nta getFormalPredicateList() to Program.formalPredicateMap();
    FormalPredicate contributes new MapEntry(predicateName(), this)
        when true
        to Program.formalPredicateMap();
        
    eq Program.getChild().formalPredicateMap() = formalPredicateMap();
}
aspect Clause {
    inh Clause Literal.clause();
    eq Clause.getChild().clause() = this;
    
    syn boolean Clause.isRule();
    eq Rule.isRule() = true;
    eq Fact.isRule() = false;
}

aspect Literal {
    syn PredicateSymbol Literal.predicate() = getPredicate();
	
 	inh boolean Literal.isFact();
    eq Clause.getChild().isFact()        = false;
    eq Fact.getHeads(int index).isFact() =  true;
    
   	syn boolean Literal.isEDB();
    eq  Literal.isEDB()    = false;
    eq  EDBLiteral.isEDB() = true;
    
    syn boolean Literal.isAtom();
    eq  Literal.isAtom() = false;
    eq  Atom.isAtom()    = true;
    
    syn boolean Literal.isNeg();
    eq  Literal.isNeg()       = false;
    eq  NEGLiteral.isNeg()    = true;
    
    syn boolean Literal.isInclusive();
    eq Literal.isInclusive() = false;
    eq InclusiveLiteral.isInclusive() = true;
    
    syn boolean Literal.hasExtendedSemantics();
    eq Literal.hasExtendedSemantics() = true;
    eq Atom.hasExtendedSemantics()    = false;
    
    inh boolean Literal.isDef();
    eq Clause.getChild().isDef() = false;
    eq Rule.getHeads().isDef()   =  true;
    eq Fact.getHeads().isDef()   =  true;

    inh boolean Literal.isUse();
    eq Clause.getChild().isUse() = false;
    eq Rule.getBody().isUse()    = true;
    
    inh Program PREDLiteral.program();
    syn List PREDLiteral.getPredicateRefList() {
    	List list = new List();
    	for(FormalPredicate fp : program().getFormalPredicates()) {
    		list.add(new PredicateRef(fp.predicateName()));
    	}
    	return list;
    }
    
    inh Program ATOMLiteral.program();
    syn List ATOMLiteral.getPredicateRefList() {
    	List list = new List();
    	for(FormalPredicate fp : program().getFormalPredicates()) {
    		if(fp.literal().isAtom())
    			list.add(new PredicateRef(fp.predicateName()));
    	}
    	return list;
    }
}

aspect Predicate {
	inh Literal PredicateSymbol.literal();
	inh Literal PredicateRef.literal();
	eq  Literal.getChild().literal() = this;
    
    public interface PredicateInterface {
    	public boolean isRef();
    	public String getPRED_ID();
    }
    PredicateSymbol implements PredicateInterface;
    PredicateRef    implements PredicateInterface;
    
    public boolean PredicateSymbol.isRef() { return false; }
    public boolean PredicateRef.isRef()    { return true; }
    
    syn boolean PredicateInterface.isFact()  = literal().isFact();
    syn boolean PredicateInterface.isEDB()   = literal().isEDB();
    syn boolean PredicateInterface.isUse()   = literal().isUse();
    syn boolean PredicateInterface.isDef()   = literal().isDef();
    syn boolean PredicateInterface.isNeg()   = literal().isNeg();
}

aspect Term {
	inh int Term.index();
	eq Literal.getChild().index() = 0;
	eq Atom.getTerms(int index).index() = index;
	
	inh Literal Term.occuresIn();
	eq  Literal.getChild().occuresIn() = this;
	
	inh boolean Term.isNested();
	eq Program.getChild().isNested() = false;
	eq TermList.getChild().isNested() = true;
}

aspect FormalPredicate {
    syn List Program.getFormalPredicateList() {
    	List list = new List();
    	for(PredicateInterface pred : uniquePredicateSymbols()) {
    		if(!pred.isRef()) {
    			FormalPredicate fp = new FormalPredicate(pred.getPRED_ID());
    			list.add(fp);
    		}
    	}
    	return list;
    }
    inh Program FormalPredicate.program();
    inh boolean FormalPredicate.hasRecursiveEDB();
    inh FormalPredicateMap FormalPredicate.formalPredicateMap();
    
    syn String FormalPredicate.predicateName() = getPRED_ID();
    syn Literal FormalPredicate.literal() = predicates().iterator().next().literal();
    syn HashSet<Literal> FormalPredicate.literals() {
    	HashSet<Literal> literals = new HashSet<Literal>();
    	for(PredicateSymbol ps : predicates()) {
    		literals.add(ps.literal());
    	}
    	return literals;
    }
    
    inh HashSet<PredicateSymbol> FormalPredicate.predicates();
    eq Program.getFormalPredicate(int index).predicates() {
    	HashSet<PredicateSymbol> predicates = new HashSet<PredicateSymbol>();
    	for(PredicateInterface pi :  predicateMap().get(getFormalPredicate(index).getPRED_ID())) {
    		if(!pi.isRef())
    			predicates.add((PredicateSymbol)pi);
    	}
    	return predicates;
    }
    
    inh HashSet<PredicateRef> FormalPredicate.predicateRefs();
    eq Program.getFormalPredicate(int index).predicateRefs() {
    	HashSet<PredicateRef> predicates = new HashSet<PredicateRef>();
    	for(PredicateInterface pi :  predicateMap().get(getFormalPredicate(index).getPRED_ID())) {
    		if(pi.isRef())
    			predicates.add((PredicateRef)pi);
    	}
    	return predicates;
    }
        
    syn FormalPredicate PredicateInterface.formalpredicate() {
    	FormalPredicate fp = literal().clause().program().formalPredicateMap().get(getPRED_ID());
    	if(fp == null) {
	    	SimpleLogger.logger().log("Each PredicateSymbol should belong to a FormalPredicate: " + this, 
	    		SimpleLogger.LogLevel.Level.ERROR);
	    	System.exit(0);
	    	return null; // Needed for JastAdd
    	}
    	return fp;
    }
}

aspect Types {
	public static final Type Type.typeType    = new TypeType();
	public static final Type Type.stringType  = new StringType();
	public static final Type Type.integerType = new IntegerType();
	public static final Type Type.predRefType = new PredRefType();
	public static final Type Type.varType     = new VariableType();
	public static final Type Type.litTypeType = new ListType(typeType);
	
	syn Type Term.type()      =  Type.typeType;
	eq Type.type()            =  Type.typeType;
    eq Variable.type()        =  Type.varType;
    eq PredicateRef.type()    =  Type.predRefType;
    eq StringConstant.type()  =  Type.stringType;
    eq IntConstant.type()     =  Type.integerType;
	eq TermList.type() {
		if(hasTerms()) return new ListType(getTerms(0).type());
		return new ListType(Type.varType);
	}
	
	syn String Type.toString()     = getClass().getSimpleName();
	syn String ListType.toString() = "ListType_" + getType().toString();
	
	syn boolean Term.isString()   = Type.typeComparator.compare(Type.stringType, type())  == 0;
	syn boolean Term.isInteger()  = Type.typeComparator.compare(Type.integerType, type()) == 0;
	syn boolean Term.isPredRef()  = Type.typeComparator.compare(Type.predRefType, type()) == 0;
	syn boolean Term.isVariable() = Type.typeComparator.compare(Type.varType, type())     == 0;
	syn boolean Term.isConstant() = isString() || isInteger() || isPredRef();
	
	public class CompareTypes implements Comparator<Type> {
		@Override
		public int compare(Type t1, Type t2) {
			return t1.toString().compareTo(t2.toString());
		}
	}
	public static final CompareTypes Type.typeComparator = new CompareTypes();
	public static boolean Term.sameType(Term t1, Term t2) { return Type.typeComparator.compare(t1.type(), t2.type()) == 0; }
	public class CoordinateTypeMap extends HashMap<Integer, HashSet<Type>> {
    	public void add(MapEntry<Integer, Type> me) {
    		HashSet<Type> types = get(me.k);
    		if(types == null) {
    			types = new HashSet<Type>();
    			types.add(me.v);
    			put(me.k, types);
    		}else {
    			types.add(me.v);
    		}
    	}
    }
    
    coll CoordinateTypeMap FormalPredicate.coordTypeMap() [new CoordinateTypeMap()] with add;
	Term contributes new MapEntry(index(), type())
        when !isNested() && occuresIn().isAtom()
        to FormalPredicate.coordTypeMap()
        for occuresIn().predicate().formalpredicate();

	/*
	syn Type Type.refType()   = typeType();
	eq StringType.refType()   = stringType();
	eq IntegerType.refType()  = integerType();
	eq PredRefType.refType()  = predRefType();
	eq VariableType.refType() = varType();
	eq ListType.refType)      = 
	*/
}
