%class "LangParser";
%package "lang.ast";

%embed {:
	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}
:};

%terminals ID, LPARA, RPARA, NUMERAL, STRING, DOT, COMMA, IMPLIED_BY, EDB;

%typeof  program             =  "Program";
%typeof  clause              =  "Clause";
%typeof  edb_literal         =  "EDBLiteral";
%typeof  real_literal        =  "RealLiteral";
%typeof  predicate_sym       =  "PredicateSymbol";
%typeof  variable            =  "Variable";
%typeof  constant            =  "Constant";
%typeof  int_constant        =  "IntConstant";
%typeof  string_constant     =  "StringConstant";
%typeof  term                =  "Term";
%typeof  term_list           =  "List";
%typeof  term_list_no_empty  =  "List";
%typeof  lit_list            =  "List";
%typeof  extensional_db      =  "ExtensionalDB";
%typeof  stmt                =  "Stmt";
%typeof  stmt_list           =  "List";
%typeof  fact                =  "Fact";
%typeof  rule                =  "Rule";
%typeof  file_location       =  "FileLocation";

%goal program;

program =  stmt_list.list {: return new Program(list); :};
stmt_list = stmt.s {: return new List().add(s); :}
            | stmt_list.list stmt.s {: return list.add(s); :}
            ;

stmt = clause
     | extensional_db
     ;

clause = rule
       | fact
       ;

rule = lit_list.heads IMPLIED_BY lit_list.body DOT {: return new Rule(heads, body); :};
fact = lit_list.heads DOT {: return new Fact(heads); :};

extensional_db = EDB LPARA edb_literal.target COMMA file_location.fn RPARA {: return new ExtensionalDB(target, fn); :};
file_location = STRING.fn {: return new FileLocation(fn); :};

real_literal = predicate_sym.pred LPARA term_list.terms RPARA {: return new RealLiteral(pred, terms); :};

edb_literal = predicate_sym.pred {: return new EDBLiteral(pred); :};

lit_list = real_literal.lit {: return new List().add(lit); :}
         | lit_list.list COMMA real_literal.c {: return list.add(c); :}
         ;

predicate_sym = ID.id {: return new PredicateSymbol(id); :};

term_list = term_list_no_empty
          | /* epsilon */ {: return new List(); :}
          ;

term_list_no_empty = term.t {: return new List().add(t); :}
                   | term_list_no_empty.list COMMA term.t {: return list.add(t); :} 
                   ;

term = variable 
     | constant
     ;

variable = ID.id {: return new Variable(id); :};
constant = int_constant
         | string_constant
         ;

int_constant = NUMERAL.num {: return new IntConstant(num); :};
string_constant = STRING.str {: return new StringConstant(str); :};
