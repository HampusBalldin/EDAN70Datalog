import java.util.HashSet;
import java.util.HashMap;
import java.util.TreeSet;
import java.util.Comparator;
import lang.relation.Relation;
import lang.relation.PseudoTuple;

aspect ModelObjectsAndPredicates {
    syn Constant Variable.Instantiation() = null;

	/**
	 * Collect All Objects available in the File.
	 */ 
    coll HashSet<Constant> Program.modelObjects() [new HashSet<Constant>()] with add;
    Constant contributes this
        when true
        to Program.modelObjects();

    syn TreeSet<Constant> Program.uniqueFileObjects() {
        TreeSet<Constant> uniqueFileObjects = new TreeSet<>(Constant.constantComparator);
        uniqueFileObjects.addAll(modelObjects());
        return uniqueFileObjects;
    }
    
    public TreeSet<Constant> Program.objects = new TreeSet<Constant>(Constant.constantComparator);

	/**
	 * Collect Predicates
	 */ 
    coll HashSet<PredicateSymbol> Program.predicateSymbols() [new HashSet<PredicateSymbol>()] with add;
    PredicateSymbol contributes this
        when true
        to Program.predicateSymbols();
        
    syn TreeSet<PredicateSymbol> Program.uniquePredicateSymbols() {
        TreeSet<PredicateSymbol> uniquePredicateSymbols = new TreeSet<>(PredicateSymbol.predicateSymbolComparator);
        uniquePredicateSymbols.addAll(predicateSymbols());
        return uniquePredicateSymbols;
    }

	/**
	 * Construct Map from a Predicate Name to all Occurrences of the Predicate
	 */ 
    syn HashMap<String, HashSet<PredicateSymbol>> Program.predicateMap() {
        HashMap<String, HashSet<PredicateSymbol>> predicateMap = new HashMap<String, HashSet<PredicateSymbol>>();
        for(PredicateSymbol pred : uniquePredicateSymbols()) {
            predicateMap.put(pred.getID(), new HashSet<PredicateSymbol>());
        }
        for(PredicateSymbol pred : predicateSymbols()) {
            HashSet<PredicateSymbol> predSet = predicateMap.get(pred.getID());
            predSet.add(pred);
        }
        return predicateMap;
    }
}

aspect Arity {
    syn int Literal.arity();
    eq MetaLiteral.arity() = -1;
    eq RealLiteral.arity() = getNumTerms();
    syn int PredicateSymbol.arity() = literal().arity();
    
    syn HashSet<Integer> FormalPredicate.arities() {
    	HashSet<Integer> arities = new HashSet<Integer>();
    	for(PredicateSymbol pred : predicates())
            arities.add(pred.arity());
        return arities;
    }
    
    syn HashSet<Integer> FormalPredicate.realArities() {
        HashSet<Integer> realArities = new HashSet<Integer>(arities());
        realArities.remove(-1);
        return realArities;
    }
    
    syn boolean FormalPredicate.uniqueArity() {
        return realArities().size() == 1;
    }

    syn int FormalPredicate.realArity() {
        if(!uniqueArity()) return 0;
        return realArities().iterator().next();
    }
    
    FormalPredicate contributes ("Different Arities for predicate symbol: " + predicateName())
        when !uniqueArity() && arities().size() != 1
        to Program.semanticErrors();
}

aspect Relation {
	public Relation FormalPredicate.relation;
	
	syn Relation FormalPredicate.fileRelation() {
		Relation r = new Relation(realArity());
		for(PredicateSymbol pred : predicates()) {
			if(pred.isFileFact()) {
				r.addTuple(new PseudoTuple((RealLiteral)pred.literal()));
			}
		}
		return r;
	}
}

aspect Rules {
	syn HashSet<Rule> FormalPredicate.useInRules() {
		HashSet<Rule> rules = new HashSet<Rule>();
		for(PredicateSymbol pred : predicates()) {
			if(pred.isUse()) {
				rules.add((Rule)pred.literal().stmt());
			}
		}
		return rules;
	}
	
	syn HashSet<Rule> FormalPredicate.definedInRules() {
		HashSet<Rule> rules = new HashSet<Rule>();
		for(PredicateSymbol pred : predicates()) {
			if(pred.isDef()) {
				rules.add((Rule)pred.literal().stmt());
			}
		}
		return rules;
	}
	
	syn RealLiteral FormalPredicate.findRuleHead(Rule rule) {
		for(RealLiteral rl : rule.getHeadss()) {
			if(rl.getPredicate().getID().equals(predicateName())) return rl;
		}
		return null;
	}
	
	coll HashSet<Variable> Rule.variablesBody() [new HashSet<Variable>()] with add;
	Variable contributes this
        when containedIn().isRuleUse()
        to Rule.variablesBody()
        for (Rule)containedIn().stmt();
        
    syn TreeSet<Variable> Rule.uniqueVariablesBody() {
    	TreeSet<Variable> vars = new TreeSet<Variable>(Term.termComparator);
    	vars.addAll(variablesBody());
    	return vars;
    }
    
    syn PseudoTuple RealLiteral.toTuple() = new PseudoTuple(this);
    
    coll HashSet<PseudoTuple> Rule.bodyTuples() [new HashSet<PseudoTuple>()] with add;
    RealLiteral contributes toTuple()
    	when isRuleUse()
    	to Rule.bodyTuples()
    	for (Rule)stmt();
}

aspect DependencyGraph {
	syn HashSet<FormalPredicate> FormalPredicate.dependsOn() {
		HashSet<FormalPredicate> rules = new HashSet<FormalPredicate>();
		for(Rule r : definedInRules()) {
			for(RealLiteral rl : r.getBodys()) {
				rules.add(rl.getPredicate().formalpredicate());
			}
		}
		return rules;
	}	
}

aspect Proof {
	syn boolean Program.mayProve(PseudoTuple t) {
		if(!t.isGround()) return false;
		for(int i = 0; i != t.size; ++i) {
			Constant c = (Constant)t.coord(i);
			if(!objects.contains(c)) return false;
		}
		return true;
	}
}